// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:test/test.dart';

import 'package:observatory/service_io.dart';
import 'service_test_common.dart';
import 'test_helper.dart';

// AUTOGENERATED START
//
// Update these constants by running:
//
// dart pkg/vm_service/test/update_line_numbers.dart runtime/observatory/tests/service/breakpoint_async_break_test.dart
//
const LINE_A = 26;
// AUTOGENERATED END

// Issue: https://github.com/dart-lang/sdk/issues/36622
Future<void> testMain() async {
  for (int i = 0; i < 2; i++) {
    if (i > 0) {
      break; // LINE_A
    }
    await Future.delayed(Duration(seconds: 1));
  }
}

var tests = <IsolateTest>[
  hasPausedAtStart,
  (Isolate isolate) async {
    var rootLib = isolate.rootLibrary;
    await rootLib.load();
    var script = rootLib.scripts[0];

    // Future breakpoint.
    var bpt = await isolate.addBreakpoint(script, LINE_A);
    expect(bpt.number, 1);
    expect(bpt.resolved, isTrue);
    expect(await bpt.location!.getLine(), LINE_A);
    expect(await bpt.location!.getColumn(), 7);

    await isolate.resume();
    await hasStoppedAtBreakpoint(isolate);

    // Remove the breakpoints.
    expect((await isolate.removeBreakpoint(bpt)).type, 'Success');
  },
];

main(args) => runIsolateTests(args, tests,
    testeeConcurrent: testMain, pause_on_start: true);
