// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// VMOptions=--verbose-debug
// VMOptions=--verbose-debug --stacktrace-every=55 --stress-async-stacks

import 'dart:async';

import 'package:test/test.dart';

import 'package:observatory/service_io.dart';
import 'test_helper.dart';

// AUTOGENERATED START
//
// Update these constants by running:
//
// dart pkg/vm_service/test/update_line_numbers.dart runtime/observatory/tests/service/async_generator_breakpoint_test.dart
//
const LINE_A = 28;
const LINE_B = 33;
const LINE_C = 38;
const LINE_D = 42;
const LINE_E = 59;
// AUTOGENERATED END

printSync() {
  print('sync'); // LINE_A
}

printAsync() async {
  await null;
  print('async'); // LINE_B
}

printAsyncStar() async* {
  await null;
  print('async*'); // LINE_C
}

printSyncStar() sync* {
  print('sync*'); // LINE_D
}

var testerReady = false;
testeeDo() {
  // We block here rather than allowing the isolate to enter the
  // paused-on-exit state before the tester gets a chance to set
  // the breakpoints because we need the event loop to remain
  // operational for the async bodies to run.
  print('testee waiting');
  while (!testerReady);

  printSync();
  var future = printAsync();
  var stream = printAsyncStar();
  var iterator = printSyncStar();

  print('middle'); // LINE_E

  future.then((v) => print(v));
  stream.toList();
  iterator.toList();
}

Future testAsync(Isolate isolate) async {
  await isolate.rootLibrary.load();
  var script = isolate.rootLibrary.scripts[0];

  var bp1 = await isolate.addBreakpoint(script, LINE_A);
  print("BP1 - $bp1");
  expect(bp1, isNotNull);
  var bp2 = await isolate.addBreakpoint(script, LINE_B);
  print("BP2 - $bp2");
  expect(bp2, isNotNull);
  var bp3 = await isolate.addBreakpoint(script, LINE_C);
  print("BP3 - $bp3");
  expect(bp3, isNotNull);
  var bp4 = await isolate.addBreakpoint(script, LINE_D);
  print("BP4 - $bp4");
  expect(bp4, isNotNull);
  var bp5 = await isolate.addBreakpoint(script, LINE_E);
  print("BP5 - $bp5");
  expect(bp5, isNotNull);

  var hits = [];

  isolate.rootLibrary.evaluate('testerReady = true').then((result) {
    print(result);
    expect((result as Instance).valueAsString, equals('true'));
  });

  var stream = await isolate.vm.getEventStream(VM.kDebugStream);
  await for (ServiceEvent event in stream) {
    if (event.kind == ServiceEvent.kPauseBreakpoint) {
      var bp = event.breakpoint;
      print('Hit $bp');
      hits.add(bp);
      await isolate.resume();

      if (hits.length == 5) break;
    }
  }

  expect(hits, equals([bp1, bp5, bp4, bp2, bp3]));
}

var tests = <IsolateTest>[testAsync];

main(args) => runIsolateTests(args, tests, testeeConcurrent: testeeDo);
